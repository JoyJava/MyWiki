
## 存储引擎

## InnoDB

### 特点

- InnoDB数据存储在表空间（tablespace）中。

- InnoDB 采用MVCC来支持高鬓发，摈弃实现4个标准个例级别。REPEATABLE TABLE（可重复读）并且通过间隙锁防止幻影读，幻影写入

- InnoDB表基于聚簇索引简历的。
  - 聚簇索引对主键查询有很高的性能，**二级索引中必须包含主键列**

- 磁盘读取数据时采用可预测性预读，能够自动在内存中创建hash索引以加速读取操作的自适应Hash索引，以及能够加速插入操作的缓冲器（insert buffer）

## MyISAM索引

#### 特点

- 全文索引、压缩、空间函数（GIS）
- 不支持事务和行级锁
- 崩溃无法安全恢复。。。

## 其他存储引擎：

- infobright：列存储
- Groonga：全文索引引擎
- OQGraph：图库
- Q4M：队列实现
- SphinxSE：全文索引
- Spider：数据切分不同的分区
- VPForMySql：垂直分区

## 索引优点

- 减少服务器需要扫描的数据量
- 避免排序和零时表
- 将随机 IO 变为顺序 IO

## 聚簇索引

- 聚簇索引并不是一种单独的索引类型,而是一种数据存储方式
- 当有聚簇索引时,`数据行实际上存放在索引的叶子节点中`的
- 如果没有主键, InnoDB 会选择唯一非空索引代替,如果没有这样的索引, InnoDB 会隐式的定义一个主键来作为聚簇索引

### 聚簇索引特点

- 优点
 - 可以把相关数据保存在一起
 - 访问数据更快,聚簇索引讲索引和数据保存在同一个 B-Tree中
 - 使用覆盖索引扫描查询可以直接使用叶子节点中的主键值
- 缺点
 - 聚簇索引数据最大限制的提高了 IO 密集型应用的性能
 - 插入速度严重依赖于插入顺序
 - 更新聚簇索引列的代价很高,应为会强制 InnoDB 将每个更新的行移动到新的位置
 - 基于聚簇索引的表在插入新行,或者主键被更新导致要移动的行的时候,可能面临`"页分裂"`的问题
 - 数据行比较稀疏(或者由于也分裂导致数据存储不连续)的时候聚簇索引可能导致全表扫描
 - 耳机索引可能比想象中的要更大, 应为在耳机索引的叶子节点包含了引用行的主键列
 - 二级索引访问需要两次索引查询,而不是一次


### 注意:


> ### 顺序的主键是什么时候回造成更坏的结果
- 对于高并发的工作负债, 在 InnoDB 中按主键顺序插入可能会造成明显的争用.因为所有的插入都发生在里面, so 并发插入可能导致 间隙锁竞争, 另外一个热点可能是 Auto_Increment 锁机制. 如果遇到这个问题,这可能需要考虑重新设计表或者应用, 或者更改 InnoDB_autoinc_lock_mode配置

### 覆盖索引

> ### 概念:
- 如果索引的也在节点中已经包含要查询的数据, 那么还有什么必要再回表查询呢? 如果一个索引包含(或者说覆盖) 所有需要查询的字段的值, 我们就成为 "覆盖索引"
- 覆盖所有是非常有用的工具, 能够极大的提高性能


#### 优点:

- 索引条目通常小鱼数据行大小, 所有如果需要读取索引, 那 MySQL 就会极大减少数据访问量
- 索引的按照列值顺序存储的, 所以对于 I/O 密集型的范围查询会比随机查询要快的多
- 由于 InnoDB 的聚簇索引, 覆盖索引对 InnoDB 表特别有用. InnoDB 的耳机所有在也在节点中保存了行的主键值, 所以如果二级索引能够覆盖查询, 这可以避免对这就索引的二次查询

#### 产生覆盖索引的条件

- 查询表中选择所有列, 而没有任何索引覆盖的了所有的列, 不过, 理论上 MySQL 还有一个捷径可以利用, where 条件中列是有所有可以覆盖的,因此 MySQL 可以使用该索引找到对应的 actor 并检查 title 是否匹配,过来之后再读取需要的数据行
- MySQL 不能在索引中执行 like 操作, 这是底层存储引擎 API 的限制

### 索引和锁
- InnoDB 在二级索引上使用共享(读)锁, 但访问主键索引需要排他(写)锁, 这消除了使用覆盖索引的可能性, 并且使得 Select for update 比 lock in share mode 或者非锁定查询要慢得多

## 索引和数据碎片
> ###概念:
B-Tree 索引可能碎片化, 这会降低查询效率, 根据设计, B-Tree 需要随机磁盘访问才能定位到叶子页, 所以随机访问是不可避免的, 如果叶子页在物理分布上的顺序而且紧密的, 查询的性能就会更好, 否则对于范围查询,索引覆盖扫描等操作来说, 速度可能会降低很多倍

- 行碎片(`Row fragmentation`)
  这种碎片指的是数据行被存储为多个地方的多个片段中, 及时查询只能从索引中方为一行记录, 行碎片也会导致性能下降
- 行间碎片 (`Intra-row fragmentation`)
  行间碎片是指逻辑上顺序页, 或者行在磁盘上的顺序存储, 行间碎片对注入全表扫描和聚簇索引扫描之类的操作有很大影响, 这些操作原本能够从磁盘上顺序存储的数据中获益
- 剩余空间碎片 (`Free space fragmentation`)
  剩余空间碎片是指数据页中有大量的空余空间, 这会导致服务器读取大量不需要的数据,从而造成浪费

对应 MyISAM 表,这三类碎片都有可能发生,但是 InnoDB 不会出现短小的行碎片, InnoDB 会移动短小的行并重写到一个片段中.

可以通过 `optimize Table` 或者导出再导入的方式来重新整理数据.

## 查询性能优化

### 1. 是否查询不需要字段, 网络 IO

### 2. 是否扫描了额外的记录

    > 衡量指标
     - 响应时间
     - 扫描行数
     - 放回行数

### Where条件,从好到坏依次为:

- 索引中使用 WHere 条件来过滤不匹配的记录, 这是存储索层完成的
- 使用索引覆盖扫描 (在 Extra列中出现了 Using index) 来返回记录, 从直接索引中过滤不需要的记录并返回命中结果, 这是 MySQL 服务器层面完成的, 但是无须再回表查询记录
- 从数据表中返回数据, 然后过滤不满足条件的记录 (在 Extra 中出现 Using Where), 这是在MySQL服务器层完成, MySQL 需要先从数据表读出记录然后过滤

## MySQL 客户端和服务端的通信协议是`"半双工"`的.

## 查询的生命周期:
- Sleep
 线程正在等待客户端发送新的请求
- Query
 线程正在执行查询或者正在将结果返回给客户端
- Locked
 在服务器层该线程正在等待锁表, 在存储引擎基本实现的锁, InnoDB 行锁.
- Analyzing and statistics
 线程正在收集存储引擎的统计信息, 并生成查询的执行计划
- Copying to tmp table [on disk]
 线程正在执行查询, 并且将其结果集都复制到一个临时表中,这种状态一般幺妹是在做 `Group By` 操作, 幺妹是文件排序操作. 或者是 union 操作
- Sorting result
 线程在对结果进行排序
- Sending data
 线程可能在多个状态之间传送数据, 或者生成数据, 或者在想客户端返回数据

## 查询优化器 (能够处理的优化类型)
- 重新定义关联表的顺序
 数据表的关联并不总是按照查询中指定的顺序进行
- 将外连接转化成内连接
 并不是所有的 `Outer Join` 语句必须以外连接的方式执行, 例如: WHERE 条件, 库表结构都可能会让外联结等价于一个内连接
-使用等价转化规则
 MySQL 可以使用一些等价变换来简化并规范表达式, 可以合并和减少比较, 还可以移除一些恒定成立和一些恒定不成立的判断, 如:(5=5 and a>5 ) 将会改写成 a>5,
再例如: (a<b and b=c) and a=5 会改成为 a5 and b=c and a=i>5
- 优化 COUNT, MIN, MAX
 索引和列是否可为空通常可以帮助 MySQL 优化这类表达式
- 覆盖索引扫描
 当索引中的列包含所有查询中需要使用的列的时候, MySQL 可以使用索引返回需要的数据, 而无需查询对应的数据行
- 子查询优化
- 提前终止查询
- 等值传播
- IN() 的比较
    MySQL 将 IN()列表中的数据线进行排序然后通过二分法查找的方式来确定列表中的值是否满足条件

###





















